{"ast":null,"code":"import { cloneDeep } from 'lodash';\nimport * as pathToRegexp from 'path-to-regexp';\n/**\n * Convert an array to a tree-structured array.\n * @param   {array}     array     The Array need to Converted.\n * @param   {string}    id        The alias of the unique ID of the object in the array.\n * @param   {string}    parentId       The alias of the parent ID of the object in the array.\n * @param   {string}    children  The alias of children of the object in the array.\n * @return  {array}    Return a tree-structured array.\n */\n\nexport function arrayToTree(array) {\n  var id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';\n  var parentId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'pid';\n  var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'children';\n  var result = [];\n  var hash = {};\n  var data = cloneDeep(array);\n  data.forEach(function (item, index) {\n    hash[data[index][id]] = data[index];\n  });\n  data.forEach(function (item) {\n    var hashParent = hash[item[parentId]];\n\n    if (hashParent) {\n      !hashParent[children] && (hashParent[children] = []);\n      hashParent[children].push(item);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n}\n/**\n * Whether the path matches the regexp if the language prefix is ignored, https://github.com/pillarjs/path-to-regexp.\n * @param   {string|regexp|array}     regexp     Specify a string, array of strings, or a regular expression.\n * @param   {string}                  pathname   Specify the pathname to match.\n * @return  {array|null}              Return the result of the match or null.\n */\n\nexport function pathMatchRegexp(regexp, pathname) {\n  return pathToRegexp.pathToRegexp(regexp).exec(pathname);\n}\n/**\n * In an array of objects, specify an object that traverses the objects whose parent ID matches.\n * @param   {array}     array     The Array need to Converted.\n * @param   {string}    current   Specify the object that needs to be queried.\n * @param   {string}    parentId  The alias of the parent ID of the object in the array.\n * @param   {string}    id        The alias of the unique ID of the object in the array.\n * @return  {array}    Return a key array.\n */\n\nexport function queryAncestors(array, current, parentId) {\n  var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'id';\n  var result = [current];\n  var hashMap = new Map();\n  array.forEach(function (item) {\n    return hashMap.set(item[id], item);\n  });\n\n  var getPath = function getPath(curr) {\n    var currentParentId = hashMap.get(curr[id])[parentId];\n\n    if (currentParentId) {\n      result.push(hashMap.get(currentParentId));\n      getPath(hashMap.get(currentParentId));\n    }\n  };\n\n  getPath(current);\n  return result;\n}\nexport function getResponseError(data) {\n  if (!data) {\n    return '';\n  }\n\n  if (Array.isArray(data.message)) {\n    var item = data.message[0];\n\n    if (!item.constraints) {\n      return data.error || 'Bad request!';\n    }\n\n    return Object.values(item.constraints)[0];\n  } // TODO - parse for langauge or others\n\n\n  return typeof data.message === 'string' ? data.message : 'Bad request!';\n}\nexport function validateUsername(text) {\n  return /^[a-z0-9]+$/.test(text);\n}","map":{"version":3,"sources":["/Volumes/Chorus/__Code Source/Slutzys/creator site/admin/src/lib/utils.ts"],"names":["cloneDeep","pathToRegexp","arrayToTree","array","id","parentId","children","result","hash","data","forEach","item","index","hashParent","push","pathMatchRegexp","regexp","pathname","exec","queryAncestors","current","hashMap","Map","set","getPath","curr","currentParentId","get","getResponseError","Array","isArray","message","constraints","error","Object","values","validateUsername","text","test"],"mappings":"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","sourcesContent":["import {\n  cloneDeep\n} from 'lodash';\nimport * as pathToRegexp from 'path-to-regexp';\n\n/**\n * Convert an array to a tree-structured array.\n * @param   {array}     array     The Array need to Converted.\n * @param   {string}    id        The alias of the unique ID of the object in the array.\n * @param   {string}    parentId       The alias of the parent ID of the object in the array.\n * @param   {string}    children  The alias of children of the object in the array.\n * @return  {array}    Return a tree-structured array.\n */\nexport function arrayToTree(\n  array,\n  id = 'id',\n  parentId = 'pid',\n  children = 'children'\n) {\n  const result = [];\n  const hash = {};\n  const data = cloneDeep(array);\n\n  data.forEach((item, index) => {\n    hash[data[index][id]] = data[index];\n  });\n\n  data.forEach((item) => {\n    const hashParent = hash[item[parentId]];\n    if (hashParent) {\n      !hashParent[children] && (hashParent[children] = []);\n      hashParent[children].push(item);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n}\n\n/**\n * Whether the path matches the regexp if the language prefix is ignored, https://github.com/pillarjs/path-to-regexp.\n * @param   {string|regexp|array}     regexp     Specify a string, array of strings, or a regular expression.\n * @param   {string}                  pathname   Specify the pathname to match.\n * @return  {array|null}              Return the result of the match or null.\n */\nexport function pathMatchRegexp(regexp, pathname) {\n  return pathToRegexp.pathToRegexp(regexp).exec(pathname);\n}\n\n/**\n * In an array of objects, specify an object that traverses the objects whose parent ID matches.\n * @param   {array}     array     The Array need to Converted.\n * @param   {string}    current   Specify the object that needs to be queried.\n * @param   {string}    parentId  The alias of the parent ID of the object in the array.\n * @param   {string}    id        The alias of the unique ID of the object in the array.\n * @return  {array}    Return a key array.\n */\nexport function queryAncestors(array, current, parentId, id = 'id') {\n  const result = [current];\n  const hashMap = new Map();\n  array.forEach((item) => hashMap.set(item[id], item));\n\n  const getPath = (curr) => {\n    const currentParentId = hashMap.get(curr[id])[parentId];\n    if (currentParentId) {\n      result.push(hashMap.get(currentParentId));\n      getPath(hashMap.get(currentParentId));\n    }\n  };\n\n  getPath(current);\n  return result;\n}\n\nexport function getResponseError(data: any) {\n  if (!data) {\n    return '';\n  }\n\n  if (Array.isArray(data.message)) {\n    const item = data.message[0];\n    if (!item.constraints) {\n      return data.error || 'Bad request!';\n    }\n    return Object.values(item.constraints)[0];\n  }\n\n  // TODO - parse for langauge or others\n  return typeof data.message === 'string' ? data.message : 'Bad request!';\n}\n\nexport function validateUsername(text: string) {\n  return /^[a-z0-9]+$/.test(text);\n}\n"]},"metadata":{},"sourceType":"module"}